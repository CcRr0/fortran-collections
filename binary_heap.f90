MODULE binary_heap
    USE vector

    IMPLICIT NONE
    PUBLIC :: HEAPIFY, HEAP_PUSH, HEAP_POP, HEAP_GET_KEY, HEAP_GET_VALUE
    PRIVATE :: SIFT_UP, SIFT_DOWN, GET_KEY

    TYPE :: HEAP_ELEM
        INTEGER :: KEY
        CLASS(*), ALLOCATABLE :: VALUE
    END TYPE HEAP_ELEM

CONTAINS
    SUBROUTINE HEAPIFY(V)
        TYPE(VEC), INTENT(INOUT) :: V

        INTEGER :: I

        DO I = SHIFTR(V%SIZE, 1), 1, -1
            CALL SIFT_DOWN(V, I)
        END DO

    END SUBROUTINE HEAPIFY

    SUBROUTINE HEAP_PUSH(V, KEY, VALUE)
        TYPE(VEC), INTENT(INOUT) :: V
        INTEGER, INTENT(IN) :: KEY
        CLASS(*), INTENT(IN) :: VALUE

        TYPE(HEAP_ELEM) :: ELEM

        ELEM%KEY = KEY
        ALLOCATE (ELEM%VALUE, SOURCE=VALUE)

        CALL VEC_PUSH_BACK(V, ELEM)
        CALL SIFT_UP(V, V%SIZE)

    END SUBROUTINE HEAP_PUSH

    SUBROUTINE HEAP_POP(V)
        TYPE(VEC), INTENT(INOUT) :: V

        IF (V%SIZE > 1) THEN
            V%DATA(1)%VALUE = V%DATA(V%SIZE)%VALUE
            CALL VEC_POP_BACK(V)
            CALL SIFT_DOWN(V, 1)
        ELSE
            CALL VEC_POP_BACK(V)
        END IF

    END SUBROUTINE HEAP_POP

    FUNCTION HEAP_GET_KEY(V) RESULT(KEY)
        TYPE(VEC), INTENT(INOUT) :: V
        INTEGER :: KEY

        KEY = GET_KEY(V, 1)

    END FUNCTION HEAP_GET_KEY

    FUNCTION HEAP_GET_VALUE(V) RESULT(VALUE)
        TYPE(VEC), INTENT(INOUT) :: V
        CLASS(*), ALLOCATABLE :: VALUE

        SELECT TYPE (ELEM => V%DATA(1)%VALUE)
        TYPE IS (HEAP_ELEM)
            ALLOCATE (VALUE, SOURCE=ELEM%VALUE)
        END SELECT

    END FUNCTION HEAP_GET_VALUE

    SUBROUTINE SIFT_UP(V, INDEX)
        TYPE(VEC), INTENT(INOUT) :: V
        INTEGER, INTENT(IN) :: INDEX

        INTEGER :: CURRENT, PARENT

        CURRENT = INDEX
        PARENT = SHIFTR(CURRENT, 1)

        DO WHILE (CURRENT > 1 .AND. GET_KEY(V, CURRENT) < GET_KEY(V, PARENT))
            CALL VEC_SWAP(V, CURRENT, PARENT)
            CURRENT = PARENT
            PARENT = SHIFTR(CURRENT, 1)
        END DO

    END SUBROUTINE SIFT_UP

    SUBROUTINE SIFT_DOWN(V, INDEX)
        TYPE(VEC), INTENT(INOUT) :: V
        INTEGER, INTENT(IN) :: INDEX

        INTEGER :: CURRENT, LESS, LEFT, RIGHT

        CURRENT = INDEX

        DO
            LESS = CURRENT
            LEFT = SHIFTL(CURRENT, 1)
            RIGHT = LEFT + 1

            IF (LEFT <= V%SIZE .AND. GET_KEY(V, LEFT) < GET_KEY(V, LESS)) THEN
                LESS = LEFT
            END IF

            IF (RIGHT <= V%SIZE .AND. GET_KEY(V, RIGHT) < GET_KEY(V, LESS)) THEN
                LESS = RIGHT
            END IF

            IF (LESS == CURRENT) THEN
                EXIT
            END IF

            CALL VEC_SWAP(V, CURRENT, LESS)
            CURRENT = LESS
        END DO

    END SUBROUTINE SIFT_DOWN

    FUNCTION GET_KEY(V, INDEX) RESULT(KEY)
        TYPE(VEC), INTENT(INOUT) :: V
        INTEGER, INTENT(IN) :: INDEX
        INTEGER :: KEY

        SELECT TYPE (ELEM => V%DATA(INDEX)%VALUE)
        TYPE IS (HEAP_ELEM)
            KEY = ELEM%KEY
        END SELECT

    END FUNCTION GET_KEY

END MODULE binary_heap
