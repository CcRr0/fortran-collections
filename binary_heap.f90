MODULE binary_heap
    IMPLICIT NONE
    PUBLIC :: HEAPIFY, HEAP_PUSH, HEAP_POP, DEALLOCATE_HEAP
    PRIVATE :: SIFT_UP, SIFT_DOWN, SWAP

    TYPE :: HEAP_ELEM
        INTEGER :: KEY
        CLASS(*), ALLOCATABLE :: VALUE
    END TYPE HEAP_ELEM

    TYPE :: HEAP
        TYPE(HEAP_ELEM), ALLOCATABLE :: STORAGE(:)
        INTEGER :: SIZE = 0
    END TYPE HEAP

CONTAINS
    SUBROUTINE HEAPIFY(HP)
        TYPE(HEAP), INTENT(INOUT) :: HP

        INTEGER :: I

        DO I = SHIFTR(HP%SIZE, 1), 1, -1
            CALL SIFT_DOWN(HP, I)
        END DO

    END SUBROUTINE HEAPIFY

    SUBROUTINE HEAP_PUSH(HP, KEY, VALUE)
        TYPE(HEAP), INTENT(INOUT) :: HP
        INTEGER, INTENT(IN) :: KEY
        CLASS(*), INTENT(IN) :: VALUE

        TYPE(HEAP_ELEM) :: ELEM

        ELEM%KEY = KEY
        ALLOCATE (ELEM%VALUE, SOURCE=VALUE)

        HP%SIZE = HP%SIZE + 1
        HP%STORAGE(HP%SIZE) = ELEM

        CALL SIFT_UP(HP, HP%SIZE)

    END SUBROUTINE HEAP_PUSH

    SUBROUTINE HEAP_POP(HP)
        TYPE(HEAP), INTENT(INOUT) :: HP

        IF (HP%SIZE > 1) THEN
            HP%STORAGE(1) = HP%STORAGE(HP%SIZE)
            CALL SIFT_DOWN(HP, 1)
        END IF

        HP%SIZE = HP%SIZE - 1

    END SUBROUTINE HEAP_POP

    SUBROUTINE DEALLOCATE_HEAP(HP)
        TYPE(HEAP), INTENT(INOUT) :: HP

        INTEGER :: I

        DO I = 1, HP%SIZE
            DEALLOCATE (HP%STORAGE(I)%VALUE)
        END DO

        DEALLOCATE (HP%STORAGE)

    END SUBROUTINE DEALLOCATE_HEAP

    SUBROUTINE SIFT_UP(HP, INDEX)
        TYPE(HEAP), INTENT(INOUT) :: HP
        INTEGER, INTENT(IN) :: INDEX

        INTEGER :: CURRENT, PARENT

        CURRENT = INDEX
        PARENT = SHIFTR(CURRENT, 1)

        DO WHILE (CURRENT > 1 .AND. HP%STORAGE(CURRENT)%KEY < HP%STORAGE(PARENT)%KEY)
            CALL SWAP(HP, CURRENT, PARENT)
            CURRENT = PARENT
            PARENT = SHIFTR(CURRENT, 1)
        END DO

    END SUBROUTINE SIFT_UP

    SUBROUTINE SIFT_DOWN(HP, INDEX)
        TYPE(HEAP), INTENT(INOUT) :: HP
        INTEGER, INTENT(IN) :: INDEX

        INTEGER :: CURRENT, LESS, LEFT, RIGHT

        CURRENT = INDEX

        DO
            LESS = CURRENT
            LEFT = SHIFTL(CURRENT, 1)
            RIGHT = LEFT + 1

            IF (LEFT <= HP%SIZE .AND. HP%STORAGE(LEFT)%KEY < HP%STORAGE(LESS)%KEY) THEN
                LESS = LEFT
            END IF

            IF (RIGHT <= HP%SIZE .AND. HP%STORAGE(RIGHT)%KEY < HP%STORAGE(LESS)%KEY) THEN
                LESS = RIGHT
            END IF

            IF (LESS == CURRENT) THEN
                EXIT
            END IF

            CALL SWAP(HP, CURRENT, LESS)
            CURRENT = LESS
        END DO

    END SUBROUTINE SIFT_DOWN

    SUBROUTINE SWAP(HP, I, J)
        TYPE(HEAP), INTENT(INOUT) :: HP
        INTEGER, INTENT(IN) :: I, J

        TYPE(HEAP_ELEM) :: TEMP

        TEMP = HP%STORAGE(I)
        HP%STORAGE(I) = HP%STORAGE(J)
        HP%STORAGE(J) = TEMP

    END SUBROUTINE SWAP

END MODULE binary_heap
