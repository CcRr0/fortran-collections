MODULE vector
    IMPLICIT NONE
    PUBLIC :: VEC, INIT_VEC, PUSH_BACK_VEC, POP_BACK_VEC, ENLARGE_VEC, DEALLOCATE_VEC

    TYPE :: VEC_ELEM
        CLASS(*), ALLOCATABLE :: VALUE
    END TYPE VEC_ELEM

    TYPE :: VEC
        TYPE(VEC_ELEM), ALLOCATABLE :: DATA(:)
        INTEGER :: SIZE, CAPACITY
    END TYPE VEC

CONTAINS
    SUBROUTINE INIT_VEC(V)
        CLASS(VEC), INTENT(INOUT) :: V

        V%SIZE = 0
        V%CAPACITY = 0
        ALLOCATE (V%DATA(0))

    END SUBROUTINE INIT_VEC

    SUBROUTINE PUSH_BACK_VEC(V, VALUE)
        CLASS(VEC), INTENT(INOUT) :: V
        CLASS(*), INTENT(IN) :: VALUE

        IF (V%SIZE == V%CAPACITY) THEN
            CALL ENLARGE_VEC(V, MAX(SHIFTL(V%CAPACITY, 1), 1))
        END IF

        V%SIZE = V%SIZE + 1
        ALLOCATE (V%DATA(V%SIZE)%VALUE, SOURCE=VALUE)

    END SUBROUTINE PUSH_BACK_VEC

    SUBROUTINE POP_BACK_VEC(V)
        CLASS(VEC), INTENT(INOUT) :: V

        DEALLOCATE (V%DATA(V%SIZE)%VALUE)
        V%SIZE = V%SIZE - 1

    END SUBROUTINE POP_BACK_VEC

    SUBROUTINE ENLARGE_VEC(V, CAPACITY)
        CLASS(VEC), INTENT(INOUT) :: V
        INTEGER, INTENT(IN) :: CAPACITY

        TYPE(VEC_ELEM), ALLOCATABLE :: TEMP(:)

        ALLOCATE (TEMP(V%SIZE), SOURCE=V%DATA(:V%SIZE))

        DEALLOCATE (V%DATA)

        V%CAPACITY = CAPACITY
        ALLOCATE (V%DATA(V%CAPACITY))

        V%DATA(:V%SIZE) = TEMP

    END SUBROUTINE ENLARGE_VEC

    SUBROUTINE DEALLOCATE_VEC(V)
        CLASS(VEC), INTENT(INOUT) :: V

        INTEGER :: I

        DO I = 1, V%SIZE
            DEALLOCATE (V%DATA(I)%VALUE)
        END DO

        DEALLOCATE (V%DATA)

    END SUBROUTINE DEALLOCATE_VEC

END MODULE vector
